#include <iostream>
#include "point3d.hpp"
#include "circle.hpp"
#include <math.h>
#include "ellipse.hpp"
#include "helix.hpp"
#include <vector>
#include <memory>
#include <stdlib.h>
#include <algorithm>

std::shared_ptr <Curve> create_random_object(int k)
{
    // k is random parameter created by index i and rand()
    std::shared_ptr<Curve> ptr = nullptr;
    // k is even and completely divisible by 3 or 5 -> create a helix
    if (k%2 == 0 && (k%5 == 0 || k%3 == 0))
    {
        ptr = std::make_shared<Helix>(std::rand(), std::rand());
    }
    // k is even and not completely divisible by 3 or 5 -> create an ellipse
    else if (k%2 == 0)
    {
        ptr = std::make_shared<Ellipse>(std::rand(), std::rand());
    }
    // k is odd -> create a circle
    else
    {
        ptr = std::make_shared<Circle>(std::rand());
    }
    return ptr;
}
int main()
{
    // populate vector random manner with random parameters
    std::vector <std::shared_ptr<Curve>> curve_cont;
    int n = 10;
    for (int i = 0; i < n; ++i)
    {
        // radii are positive, because they are generated by rand()
        // rand() generated random numbers in [0, RAND_MAX]
        curve_cont.push_back(create_random_object(i + std::rand()));
    }
    // print coordinates of points and derivatives of all curves in the container at t=PI/4
    std::vector <std::shared_ptr<Curve>> circle_cont;
    float t = 3.14/4;
    for (int i = 0; i < n; ++i)
    {
        std::cout << "Point: " << curve_cont[i]->calc_at(t) << " ";
        std::cout << "First derivative: " << curve_cont[i]->calc_derivative_at(t) << std::endl;
        // populate the second container
        if (typeid(*curve_cont[i]) == typeid(Circle))
        {
            // share circle  via shared_ptr
            circle_cont.push_back(std::shared_ptr<Curve>(curve_cont[i]));
        }
    }
    //sort the second container in the ascending order
    std::sort(circle_cont.begin(), circle_cont.end(),
              [](const std::shared_ptr<Curve>& x, const std::shared_ptr<Curve>& y)
    {return x->get_radius() < y->get_radius();});

    // print the sorted container and compute the sum of radii in the container
    float sum_of_circles = 0;
    for (const auto& item: circle_cont)
    {
        std::cout << item->get_radius() << std::endl;
        sum_of_circles += item->get_radius();
    }
    std::cout << "sum: " << sum_of_circles << std::endl;

    return 0;
}
